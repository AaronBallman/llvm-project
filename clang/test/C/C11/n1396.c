// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 5
// RUN: %clang_cc1 -emit-llvm -o - %s | FileCheck %s

/* WG14 N1396: Clang 15
 * Wide function returns (alternate proposal)
 *
 * This only applies if attempting to conform to Annex F. Clang is not claiming
 * conformance to Annex F, but we do aim for conformance. This means that the
 * return statement converts the value to the return type of the function
 * rather than return the result in a wider evaluation format. We test this by
 * using a return statement without a cast and ensure it produces the same IR
 * as a return statement with an explicit cast.
 *
 * We claim Clang 15 for conformance because that's the first version that
 * supported #pragma clang fp eval_method source|extended
 */

// CHECK-LABEL: define dso_local float @extended_float_func(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP0]] to double
// CHECK-NEXT:    [[MUL:%.*]] = fmul double [[CONV]], 1.000000e+00
// CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[MUL]] to float
// CHECK-NEXT:    ret float [[CONV1]]
//
float extended_float_func(float x) {
#pragma clang fp eval_method(extended)
  return x * 1.0f;
}

// CHECK-LABEL: define dso_local float @extended_float_func_cast(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP0]] to double
// CHECK-NEXT:    [[MUL:%.*]] = fmul double [[CONV]], 1.000000e+00
// CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[MUL]] to float
// CHECK-NEXT:    ret float [[CONV1]]
//
float extended_float_func_cast(float x) {
#pragma clang fp eval_method(extended)
  return (float)(x * 1.0f);
}

// CHECK-LABEL: define dso_local float @extended_double_func(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP0]] to double
// CHECK-NEXT:    [[MUL:%.*]] = fmul double [[CONV]], 1.000000e+00
// CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[MUL]] to float
// CHECK-NEXT:    ret float [[CONV1]]
//
float extended_double_func(float x) {
#pragma clang fp eval_method(extended)
  return x * 1.0;
}

// CHECK-LABEL: define dso_local float @extended_double_func_cast(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP0]] to double
// CHECK-NEXT:    [[MUL:%.*]] = fmul double [[CONV]], 1.000000e+00
// CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[MUL]] to float
// CHECK-NEXT:    ret float [[CONV1]]
//
float extended_double_func_cast(float x) {
#pragma clang fp eval_method(extended)
  return (float)(x * 1.0);
}

// CHECK-LABEL: define dso_local float @float_source_func(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = fmul float [[TMP0]], 1.000000e+00
// CHECK-NEXT:    ret float [[MUL]]
//
float float_source_func(float x) {
#pragma clang fp eval_method(source)
  return x * 1.0f;
}

// CHECK-LABEL: define dso_local float @float_source_func_cast(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[MUL:%.*]] = fmul float [[TMP0]], 1.000000e+00
// CHECK-NEXT:    ret float [[MUL]]
//
float float_source_func_cast(float x) {
#pragma clang fp eval_method(source)
  return (float)(x * 1.0f);
}

// CHECK-LABEL: define dso_local float @double_source_func(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP0]] to double
// CHECK-NEXT:    [[MUL:%.*]] = fmul double [[CONV]], 1.000000e+00
// CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[MUL]] to float
// CHECK-NEXT:    ret float [[CONV1]]
//
float double_source_func(float x) {
#pragma clang fp eval_method(source)
  return x * 1.0;
}

// CHECK-LABEL: define dso_local float @double_source_func_cast(
// CHECK-SAME: float noundef [[X:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  [[ENTRY:.*:]]
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca float, align 4
// CHECK-NEXT:    store float [[X]], ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load float, ptr [[X_ADDR]], align 4
// CHECK-NEXT:    [[CONV:%.*]] = fpext float [[TMP0]] to double
// CHECK-NEXT:    [[MUL:%.*]] = fmul double [[CONV]], 1.000000e+00
// CHECK-NEXT:    [[CONV1:%.*]] = fptrunc double [[MUL]] to float
// CHECK-NEXT:    ret float [[CONV1]]
//
float double_source_func_cast(float x) {
#pragma clang fp eval_method(source)
  return (float)(x * 1.0);
}
